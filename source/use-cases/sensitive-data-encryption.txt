=========================
Sensitive Data Encryption
=========================

.. default-domain:: mongodb

.. contents:: On this page
   :local:
   :backlinks: none
   :depth: 2
   :class: singlecol

Introduction
------------

Cras sed rutrum nisi, vitae tristique risus. Aliquam erat volutpat.
Donec auctor nisl eget ornare accumsan. Pellentesque lectus tortor,
consectetur molestie pellentesque ac, blandit non libero.

Problem
~~~~~~~

Pellentesque non mi et est congue mattis pretium sit amet mi. Praesent
nec tortor nec arcu molestie dapibus. Phasellus at nunc ut quam molestie
finibus. Suspendisse finibus lectus eget nulla eleifend, vel consequat
leo rhoncus. Phasellus lacinia tortor id aliquet condimentum. Morbi
sodales est a leo rhoncus, non pretium neque dignissim.

Solution
~~~~~~~~

Praesent sit amet elit pretium mi molestie porta a sit amet ipsum. Sed
sollicitudin purus et mi blandit sodales.

- Deterministic vs Non-Deterministic

Procedure
---------

Requirements
~~~~~~~~~~~~

- Point to setup and install directions
- Nullam imperdiet lorem vitae vulputate lacinia.
- Donec eget velit tincidunt, gravida diam ac, efficitur lacus.

A. Create a Local Master Key
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Aenean eu consequat lorem. Ut posuere est sed sodales pharetra. Cras
volutpat, massa laoreet varius dictum, leo odio porttitor ante, nec
auctor tortor orci et mi. Maecenas tempor, lacus vehicula molestie
pulvinar, ante eros faucibus odio, sed consequat quam tellus vel arcu.
Vestibulum ante ipsum primis in faucibus orci luctus et ultrices posuere
cubilia Curae; Nunc non interdum purus, ultricies laoreet tortor.

B. Define a JSON Schema
~~~~~~~~~~~~~~~~~~~~~~~

In MongoDB, we can create and specify a `JSON Schema <https://docs.mongodb.com/manual/reference/operator/query/jsonSchema/#json-schema>`_ on a collection to `validate data 
<https://docs.mongodb.com/manual/core/schema-validation/>`_ during insert and update operations.
Within the context of Field Level Encryption, JSONSchema is used to
specify several configuration details.

* Drivers can automatically encrypt and decrypt fields
* To do so, you need to specify two things in JSON Schema for each encrypted field:
    a) The encryption type (deterministic or random)
    b) The data key
* You can use a single data key for all encrypted fields or you can use individual data keys that are specific to each field.


To create a field that is encrypted, you first have to define it's schema. The following illustrates a quick example of a JSONSchema of a deterministically encrypted field called address:

.. code::

    "address": {
        "encrypt": {
            "bsonType": "string",
            "keyId": [
                {
                    "$binary": {
                    "base64": <keyId>,
                    "subType": "04"
                    }
                }
            ],
            "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic"
        }
    }


In this complete example we will go over the creation of a schema for a collection
that represents patient data
in a medical office. Some fields use deterministic encryption, and others
use random (probabilistic) encryption. 

The structure for the schema will be as follows. Note that each field falls under
3 categories: unencrypted fields, randomly encrypted fields, deterministically encrypted fields. 

.. code::

    name: String
    ssn: Encrypted Int using deterministic encryption
    bloodType: Encrypted String using random encryption
    insurance: Object
    insurance.policyNumber Encrypted Int using deterministic encryption
    patientInfo.provider String
    medicalRecords: Encrypted array of documents using random encryption

Explanation of encryption choices
``````````````````````````````````
* ``ssn`` is deterministically encrypted because deterministic encrypted fields are queryable unique fields, and a receptionist might want to query this 
* ``bloodType`` has low cardinality, meaning there is a very limited amount of values this field can have, so we will use random encryption for this field in order to prevent against hackers building a dictionary of ciphertexts for blood types (which is possible if the field is deterministically encrypted and has low cardinality).
* ``insurance.policyNumber`` is deterministically encrypted for the same reason as ssn, and also it provides an example of encryption with a nested document
* ``medicalRecords`` array is randomly encrypted because array fields cannot be encrypted deterministically


.. tabs::

   tabs:

     - id: java-jsonschema-generation
       name: "Java"
       content: |
       
        The following code creates a JSONSchema object that enforces encryption on various 
        fields. The createSecureClient is a method that calls createJSONSchema and passes 
        it a dataKey id in order to create a client that uses the JSONSchema returned
        from createJSONSchema. However, the createSecureClient is abstracted from
        this section for focus on the creation of schema. 

        .. code-block:: java

            import com.mongodb.*;
            import com.mongodb.client.MongoClient;
            import com.mongodb.client.MongoClients;
            import com.mongodb.client.MongoCollection;
            import com.mongodb.client.model.vault.DataKeyOptions;
            import com.mongodb.client.vault.ClientEncryptions;

            import org.bson.BsonDocument;

            import java.util.Base64;
            import java.util.Map;

            import org.json.*;

            public class FieldLevelEncryptionDemo {
                static String dbName = "fieldLevelEncryptionDemo001";
                static String collectionName = "patients";
                public static void main(String[] args) {
                    // MongoCollection secureCollection = createSecureClient().getDatabase(dbName).getCollection(collectionName);
                    // ...
                }
                public static JSONObject createEncryptedFieldType(String keyId, String bsonType, boolean isDeterministic) {
                    JSONObject binaryForKey = new JSONObject();
                    binaryForKey.put("base64", keyId);
                    binaryForKey.put("subType", "04");
                    JSONObject binWrapper = new JSONObject();
                    binWrapper.put("$binary", binaryForKey);
                    JSONObject encryptedFieldWrap = new JSONObject();
                    JSONObject encrypt = new JSONObject();
                    encrypt.put("bsonType", bsonType);

                    if (isDeterministic) {
                        encrypt.put("algorithm", "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic");
                    } else {
                        encrypt.put("algorithm", "AEAD_AES_256_CBC_HMAC_SHA_512-Random");
                    }
            
                    encrypt.put("keyId", new JSONArray().put(binWrapper));
                    encryptedFieldWrap.put("encrypt", encrypt);
                    return encryptedFieldWrap;
                }
                public static JSONObject createStandardFieldType(String bsonType) {
                    JSONObject standardField = new JSONObject();
                    standardField.put("bsonType", bsonType);
                    standardField.put("description", "must be a " + bsonType + " and is required");
                    return standardField;
                }
                public static String getJSONSchema(String keyId){
                    JSONObject properties = new JSONObject();
                    properties.put("name", getStandardField("string"));
                    properties.put("ssn", getEncryptedField(keyId, "int", true));
                    properties.put("bloodType", getEncryptedField(keyId, "string", false)); 
                    JSONObject insurance = new JSONObject();
                    insurance.put("bsonType", "object");
                    JSONObject insuranceProperties = new JSONObject();
                        insuranceProperties.put("policyNumber", getEncryptedField(keyId, "int", true));
                        insuranceProperties.put("provider", getStandardField("string"));
                    insurance.put("properties", insuranceProperties);
                    properties.put("insurance", insurance);
                    JSONObject medicalRecords = getEncryptedField(keyId, "array", false);
                    properties.put("medicalRecords",medicalRecords);
                    JSONObject patientsSchema = new JSONObject();
                    patientsSchema.put("properties", properties);
                    patientsSchema.put("bsonType", "object");
                    String patientsSchemaAsString = patientsSchema.toString();
                    return patientsSchemaAsString;
                }
                public static MongoClient createSecureClient() {
                    // ...
                }
            }

Running the createJSONSchema method will return the following JSON schema:

.. code::


    
    {
        "bsonType": "object",
        "properties": {
            "insurance": {
                "bsonType": "object",
                "properties": {
                    "provider": {
                        "bsonType": "string",
                        "description": "must be a string and is required"
                    },
                    "policyNumber": {
                        "encrypt": {
                            "bsonType": "int",
                            "keyId": [
                            {
                                "$binary": {
                                "base64": "VPdDvc8/QAaLwj0J0ZjCpA==",
                                "subType": "04"
                                }
                            }
                            ],
                            "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic"
                        }
                    }
                }
            },
            "medicalRecords": {
                "encrypt": {
                    "bsonType": "array",
                    "keyId": [
                    {
                        "$binary": {
                        "base64": "VPdDvc8/QAaLwj0J0ZjCpA==",
                        "subType": "04"
                        }
                    }
                    ],
                    "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Random"
                }
            },
            "name": {
                "bsonType": "string",
                "description": "must be a string and is required"
            },
            "bloodType": {
                "encrypt": {
                    "bsonType": "string",
                    "keyId": [
                    {
                        "$binary": {
                            "base64": "VPdDvc8/QAaLwj0J0ZjCpA==",
                            "subType": "04"
                        }
                    }
                    ],
                    "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Random"
                }
            },
            "ssn": {
                "encrypt": {
                    "bsonType": "int",
                    "keyId": [
                    {
                        "$binary": {
                            "base64": "VPdDvc8/QAaLwj0J0ZjCpA==",
                            "subType": "04"
                        }
                    }
                    ],
                    "algorithm": "AEAD_AES_256_CBC_HMAC_SHA_512-Deterministic"
                }
            }
        }
    }


C. Configure the MongoDB Client
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Donec sem felis, iaculis id pharetra sed, sollicitudin ut nisl.
Suspendisse commodo sagittis ante in ullamcorper. Etiam viverra
pellentesque suscipit. Pellentesque interdum egestas libero, ut varius
velit congue vel.

D. Perform Encrypted Read/Write Operations
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Etiam hendrerit posuere justo, ac hendrerit lorem pellentesque sed.
Fusce ullamcorper neque eu libero aliquam, sed placerat sapien cursus.
Vestibulum maximus magna sed velit feugiat tempor.

Ut accumsan pellentesque metus, at porta felis dapibus vulputate. Aenean
malesuada interdum libero in feugiat. Fusce pharetra massa eget leo
varius, et gravida massa tempus.

Ut mattis eros elit, sed ultrices purus lacinia sed. Curabitur tincidunt
tellus eget neque porta dictum ac vel orci. Vestibulum ante ipsum primis
in faucibus orci luctus et ultrices posuere cubilia Curae.

Praesent feugiat arcu non risus elementum eleifend. Nullam sed iaculis
erat.

E. Convert to a Remote Master Key
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Fusce porta lectus et enim vehicula malesuada. In porttitor ipsum eu
dictum congue. Fusce pharetra sagittis lacus sed posuere. Donec porta
posuere gravida. Quisque nisi massa, condimentum vitae ligula eget,
fringilla malesuada quam. Mauris in semper nulla, non blandit tortor.
Mauris consequat eget urna at eleifend. Suspendisse potenti. Fusce at
justo malesuada, finibus felis non, dignissim nisl. Ut blandit nulla sit
amet massa euismod vehicula.

Summary
-------

- What we wanted to do
- What we did
- More reading
